[assembly: System.Reflection.AssemblyMetadata("RepositoryUrl", "https://github.com/arika0093/Configuration.Writable")]
namespace Configuration.Writable.Configure
{
    public interface ILocationBuilder
    {
        System.Collections.Generic.IEnumerable<string> SaveLocationPaths { get; }
        Configuration.Writable.Configure.ILocationBuilder AddFilePath(string path);
    }
    public interface ILocationBuilderWithDirectory : Configuration.Writable.Configure.ILocationBuilder
    {
        Configuration.Writable.Configure.ILocationBuilder UseCurrentDirectory(bool enabled = true);
        Configuration.Writable.Configure.ILocationBuilder UseExecutableDirectory(bool enabled = true);
        Configuration.Writable.Configure.ILocationBuilder UseSpecialFolder(System.Environment.SpecialFolder folder, bool enabled = true);
        Configuration.Writable.Configure.ILocationBuilder UseStandardSaveDirectory(string applicationId, bool enabled = true);
    }
    public class WritableOptionsConfigBuilder<T> : Configuration.Writable.Configure.ILocationBuilder, Configuration.Writable.Configure.ILocationBuilderWithDirectory, System.IEquatable<Configuration.Writable.Configure.WritableOptionsConfigBuilder<T>>
        where T :  class, new ()
    {
        public WritableOptionsConfigBuilder() { }
        public string? FilePath { get; set; }
        public Configuration.Writable.FileProvider.IFileProvider? FileProvider { get; set; }
        public Configuration.Writable.IFormatProvider FormatProvider { get; set; }
        public string InstanceName { get; set; }
        public Microsoft.Extensions.Logging.ILogger? Logger { get; set; }
        public bool RegisterInstanceToContainer { get; set; }
        public System.Collections.Generic.IEnumerable<string> SaveLocationPaths { get; }
        public string SectionName { get; set; }
        public bool UseDataAnnotationsValidation { get; set; }
        public Configuration.Writable.Configure.ILocationBuilder AddFilePath(string path) { }
        public Configuration.Writable.WritableOptionsConfiguration<T> BuildOptions() { }
        public Configuration.Writable.Configure.ILocationBuilder UseCurrentDirectory(bool enabled = true) { }
        public Configuration.Writable.Configure.ILocationBuilder UseExecutableDirectory(bool enabled = true) { }
        public Configuration.Writable.Configure.ILocationBuilder UseSpecialFolder(System.Environment.SpecialFolder folder, bool enabled = true) { }
        public Configuration.Writable.Configure.ILocationBuilder UseStandardSaveDirectory(string applicationId, bool enabled = true) { }
        public void WithValidator(Microsoft.Extensions.Options.IValidateOptions<T> validator) { }
        public void WithValidator<TValidator>()
            where TValidator : Microsoft.Extensions.Options.IValidateOptions<T>, new () { }
        public void WithValidatorFunction(System.Func<T, Microsoft.Extensions.Options.ValidateOptionsResult> validator) { }
    }
}
namespace Configuration.Writable.FileProvider
{
    public class CommonFileProvider : Configuration.Writable.FileProvider.IFileProvider, System.IDisposable
    {
        public CommonFileProvider() { }
        public virtual int BackupMaxCount { get; set; }
        public virtual int MaxRetryCount { get; set; }
        public virtual System.Func<int, int> RetryDelay { get; set; }
        public void Dispose() { }
        protected virtual void Dispose(bool disposing) { }
        public virtual bool FileExists(string path) { }
        protected virtual void GenerateBackupFile(string path, Microsoft.Extensions.Logging.ILogger? logger) { }
        public virtual System.IO.Stream? GetFileStream(string path) { }
        protected virtual string GetTemporaryFilePath(string path) { }
        public virtual System.Threading.Tasks.Task SaveToFileAsync(string path, System.ReadOnlyMemory<byte> content, Microsoft.Extensions.Logging.ILogger? logger = null, System.Threading.CancellationToken cancellationToken = default) { }
        protected virtual System.Threading.Tasks.Task WriteContentToFileAsync(string path, System.ReadOnlyMemory<byte> content, System.Threading.CancellationToken cancellationToken) { }
    }
    public interface IFileProvider
    {
        bool FileExists(string path);
        System.IO.Stream? GetFileStream(string path);
        System.Threading.Tasks.Task SaveToFileAsync(string path, System.ReadOnlyMemory<byte> content, Microsoft.Extensions.Logging.ILogger? logger = null, System.Threading.CancellationToken cancellationToken = default);
    }
    public class ZipFileProvider : Configuration.Writable.FileProvider.IFileProvider, System.IDisposable
    {
        public ZipFileProvider() { }
        public string EntriesDirectory { get; set; }
        public string ZipFileName { get; set; }
        public void Dispose() { }
        protected virtual void Dispose(bool disposing) { }
        public bool FileExists(string path) { }
        public System.IO.Stream? GetFileStream(string path) { }
        public System.Threading.Tasks.Task SaveToFileAsync(string path, System.ReadOnlyMemory<byte> content, Microsoft.Extensions.Logging.ILogger? logger = null, System.Threading.CancellationToken cancellationToken = default) { }
    }
}
namespace Configuration.Writable
{
    public abstract class FormatProviderBase : Configuration.Writable.IFormatProvider
    {
        protected FormatProviderBase() { }
        public abstract string FileExtension { get; }
        public virtual Configuration.Writable.FileProvider.IFileProvider FileProvider { get; set; }
        public abstract T LoadConfiguration<T>(Configuration.Writable.WritableOptionsConfiguration<T> options)
            where T :  class, new ();
        public abstract T LoadConfiguration<T>(System.IO.Stream stream, Configuration.Writable.WritableOptionsConfiguration<T> options)
            where T :  class, new ();
        public abstract System.Threading.Tasks.Task SaveAsync<T>(T config, Configuration.Writable.WritableOptionsConfiguration<T> options, System.Threading.CancellationToken cancellationToken = default)
            where T :  class, new ();
        protected static object CreateNestedSection(string sectionName, object value) { }
        protected static string[] GetSplitedSections(string sectionName) { }
    }
    public interface IFormatProvider
    {
        string FileExtension { get; }
        Configuration.Writable.FileProvider.IFileProvider FileProvider { get; set; }
        T LoadConfiguration<T>(Configuration.Writable.WritableOptionsConfiguration<T> options)
            where T :  class, new ();
        T LoadConfiguration<T>(System.IO.Stream stream, Configuration.Writable.WritableOptionsConfiguration<T> options)
            where T :  class, new ();
        System.Threading.Tasks.Task SaveAsync<T>(T config, Configuration.Writable.WritableOptionsConfiguration<T> options, System.Threading.CancellationToken cancellationToken = default)
            where T :  class, new ();
    }
    public interface IWritableOptionConfigRegistory<T>
        where T :  class, new ()
    {
        event System.Action<Configuration.Writable.WritableOptionsConfiguration<T>> OnAdded;
        event System.Action<string> OnRemoved;
        void Clear();
        Configuration.Writable.WritableOptionsConfiguration<T> Get(string instanceName);
        System.Collections.Generic.IEnumerable<string> GetInstanceNames();
        bool TryAdd(System.Action<Configuration.Writable.Configure.WritableOptionsConfigBuilder<T>> configure);
        bool TryRemove(string instanceName);
    }
    public interface IReadOnlyNamedOptions<T> : Configuration.Writable.IReadOnlyOptionsCore<T>
        where T :  class, new ()
    {
        T Get(string name);
        Configuration.Writable.WritableOptionsConfiguration<T> GetOptionsConfiguration(string name);
    }
    public interface IReadOnlyOptionsCore<T>
        where T :  class, new ()
    {
        System.IDisposable? OnChange(System.Action<T, string?> listener);
    }
    public interface IReadOnlyOptions<T> : Configuration.Writable.IReadOnlyOptionsCore<T>
        where T :  class, new ()
    {
        T CurrentValue { get; }
        Configuration.Writable.WritableOptionsConfiguration<T> GetOptionsConfiguration();
    }
    public interface IWritableNamedOptions<T> : Configuration.Writable.IReadOnlyNamedOptions<T>, Configuration.Writable.IReadOnlyOptionsCore<T>
        where T :  class, new ()
    {
        System.Threading.Tasks.Task SaveAsync(string name, System.Action<T> configUpdater, System.Threading.CancellationToken cancellationToken = default);
        System.Threading.Tasks.Task SaveAsync(string name, T newConfig, System.Threading.CancellationToken cancellationToken = default);
    }
    public interface IWritableOptions<T> : Configuration.Writable.IReadOnlyOptionsCore<T>, Configuration.Writable.IReadOnlyOptions<T>
        where T :  class, new ()
    {
        System.Threading.Tasks.Task SaveAsync(System.Action<T> configUpdater, System.Threading.CancellationToken cancellationToken = default);
        System.Threading.Tasks.Task SaveAsync(T newConfig, System.Threading.CancellationToken cancellationToken = default);
    }
    public class JsonFormatProvider : Configuration.Writable.FormatProviderBase
    {
        public JsonFormatProvider() { }
        public System.Text.Encoding Encoding { get; init; }
        public override string FileExtension { get; }
        public System.Text.Json.JsonSerializerOptions JsonSerializerOptions { get; init; }
        public override T LoadConfiguration<T>(Configuration.Writable.WritableOptionsConfiguration<T> options)
            where T :  class, new () { }
        public override T LoadConfiguration<T>(System.IO.Stream stream, Configuration.Writable.WritableOptionsConfiguration<T> options)
            where T :  class, new () { }
        public override System.Threading.Tasks.Task SaveAsync<T>(T config, Configuration.Writable.WritableOptionsConfiguration<T> options, System.Threading.CancellationToken cancellationToken = default)
            where T :  class, new () { }
    }
    public class WritableOptionsConfiguration<T> : System.IEquatable<Configuration.Writable.WritableOptionsConfiguration<T>>
        where T :  class, new ()
    {
        public WritableOptionsConfiguration() { }
        public required string ConfigFilePath { get; init; }
        public required Configuration.Writable.IFormatProvider FormatProvider { get; init; }
        public required string InstanceName { get; init; }
        public Microsoft.Extensions.Logging.ILogger? Logger { get; init; }
        public required int OnChangeThrottleMs { get; init; }
        public required string SectionName { get; init; }
        public System.Func<T, Microsoft.Extensions.Options.ValidateOptionsResult>? Validator { get; init; }
    }
    public static class WritableOptionsCoreExtensions
    {
        public static Microsoft.Extensions.DependencyInjection.IServiceCollection AddWritableOptionsCore<T>(this Microsoft.Extensions.DependencyInjection.IServiceCollection services)
            where T :  class, new () { }
        public static Microsoft.Extensions.DependencyInjection.IServiceCollection AddWritableOptionsCore<T>(this Microsoft.Extensions.DependencyInjection.IServiceCollection services, string instanceName)
            where T :  class, new () { }
    }
}
namespace Configuration.Writable.Testing
{
    public class WritableOptionsSimpleInstance<T>
        where T :  class, new ()
    {
        public WritableOptionsSimpleInstance() { }
        public Configuration.Writable.IWritableOptions<T> GetOptions() { }
        public void Initialize() { }
        public void Initialize(System.Action<Configuration.Writable.Configure.WritableOptionsConfigBuilder<T>> configurationOptions) { }
    }
    public static class WritableOptionsStub
    {
        public static Configuration.Writable.Testing.WritableOptionsStub<T> Create<T>(System.Collections.Generic.Dictionary<string, T> namedValues)
            where T :  class, new () { }
        public static Configuration.Writable.Testing.WritableOptionsStub<T> Create<T>(T value)
            where T :  class, new () { }
    }
    public class WritableOptionsStub<T> : Configuration.Writable.IReadOnlyNamedOptions<T>, Configuration.Writable.IReadOnlyOptionsCore<T>, Configuration.Writable.IReadOnlyOptions<T>, Configuration.Writable.IWritableNamedOptions<T>, Configuration.Writable.IWritableOptions<T>
        where T :  class, new ()
    {
        public WritableOptionsStub(System.Collections.Generic.Dictionary<string, T> namedValues) { }
        public WritableOptionsStub(T value) { }
        public T CurrentValue { get; }
        public T Get(string? name) { }
        public Configuration.Writable.WritableOptionsConfiguration<T> GetOptionsConfiguration() { }
        public Configuration.Writable.WritableOptionsConfiguration<T> GetOptionsConfiguration(string name) { }
        public System.IDisposable? OnChange(System.Action<T, string?> listener) { }
        public System.Threading.Tasks.Task SaveAsync(System.Action<T> configUpdater, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task SaveAsync(T newConfig, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task SaveAsync(string name, System.Action<T> configUpdater, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task SaveAsync(string name, T newConfig, System.Threading.CancellationToken cancellationToken = default) { }
    }
}