[assembly: System.Reflection.AssemblyMetadata("RepositoryUrl", "https://github.com/arika0093/Configuration.Writable")]
namespace Configuration.Writable.FileProvider
{
    public class CommonFileProvider : Configuration.Writable.FileProvider.IFileProvider, System.IDisposable
    {
        public CommonFileProvider() { }
        public virtual int BackupMaxCount { get; set; }
        public virtual int MaxRetryCount { get; set; }
        public virtual System.Func<int, int> RetryDelay { get; set; }
        public void Dispose() { }
        protected virtual void Dispose(bool disposing) { }
        public virtual bool FileExists(string path) { }
        protected virtual void GenerateBackupFile(string path, Microsoft.Extensions.Logging.ILogger? logger) { }
        public virtual System.IO.Stream? GetFileStream(string path) { }
        protected virtual string GetTemporaryFilePath(string path) { }
        public virtual System.Threading.Tasks.Task SaveToFileAsync(string path, System.ReadOnlyMemory<byte> content, System.Threading.CancellationToken cancellationToken = default, Microsoft.Extensions.Logging.ILogger? logger = null) { }
        protected virtual System.Threading.Tasks.Task WriteContentToFileAsync(string path, System.ReadOnlyMemory<byte> content, System.Threading.CancellationToken cancellationToken) { }
    }
    public interface IFileProvider
    {
        bool FileExists(string path);
        System.IO.Stream? GetFileStream(string path);
        System.Threading.Tasks.Task SaveToFileAsync(string path, System.ReadOnlyMemory<byte> content, System.Threading.CancellationToken cancellationToken = default, Microsoft.Extensions.Logging.ILogger? logger = null);
    }
}
namespace Configuration.Writable
{
    public interface IOptionOperator<T>
        where T :  class
    {
        void DeleteKey(System.Linq.Expressions.Expression<System.Func<T, object?>> selector);
    }
    public interface IReadOnlyOptions<T> : Microsoft.Extensions.Options.IOptionsMonitor<T>
        where T :  class
    {
        Configuration.Writable.WritableConfigurationOptions<T> GetConfigurationOptions();
        Configuration.Writable.WritableConfigurationOptions<T> GetConfigurationOptions(string name);
    }
    public interface IWritableConfigProvider
    {
        string FileExtension { get; }
        Configuration.Writable.FileProvider.IFileProvider FileProvider { get; set; }
        T LoadConfiguration<T>(Configuration.Writable.WritableConfigurationOptions<T> options)
            where T :  class;
        T LoadConfiguration<T>(System.IO.Stream stream, Configuration.Writable.WritableConfigurationOptions<T> options)
            where T :  class;
        System.Threading.Tasks.Task SaveAsync<T>(T config, Configuration.Writable.OptionOperations<T> operations, Configuration.Writable.WritableConfigurationOptions<T> options, System.Threading.CancellationToken cancellationToken = default)
            where T :  class;
    }
    public interface IWritableOptions<T> : Configuration.Writable.IReadOnlyOptions<T>, Microsoft.Extensions.Options.IOptionsMonitor<T>
        where T :  class
    {
        System.Threading.Tasks.Task SaveAsync(System.Action<T> configUpdater, System.Threading.CancellationToken cancellationToken = default);
        System.Threading.Tasks.Task SaveAsync(System.Action<T, Configuration.Writable.IOptionOperator<T>> configUpdaterWithOperator, System.Threading.CancellationToken cancellationToken = default);
        System.Threading.Tasks.Task SaveAsync(T newConfig, System.Threading.CancellationToken cancellationToken = default);
        System.Threading.Tasks.Task SaveWithNameAsync(string name, System.Action<T> configUpdater, System.Threading.CancellationToken cancellationToken = default);
        System.Threading.Tasks.Task SaveWithNameAsync(string name, System.Action<T, Configuration.Writable.IOptionOperator<T>> configUpdaterWithOperator, System.Threading.CancellationToken cancellationToken = default);
        System.Threading.Tasks.Task SaveWithNameAsync(string name, T newConfig, System.Threading.CancellationToken cancellationToken = default);
    }
    public sealed class OptionOperations<T> : Configuration.Writable.IOptionOperator<T>
        where T :  class
    {
        public OptionOperations() { }
        public bool HasOperations { get; }
        public System.Collections.Generic.IReadOnlyList<string> KeysToDelete { get; }
        public void DeleteKey(System.Linq.Expressions.Expression<System.Func<T, object?>> selector) { }
    }
    public class WritableConfigJsonProvider : Configuration.Writable.WritableConfigProviderBase
    {
        public WritableConfigJsonProvider() { }
        public System.Text.Encoding Encoding { get; init; }
        public override string FileExtension { get; }
        public System.Text.Json.JsonSerializerOptions JsonSerializerOptions { get; init; }
        public override T LoadConfiguration<T>(Configuration.Writable.WritableConfigurationOptions<T> options)
            where T :  class { }
        public override T LoadConfiguration<T>(System.IO.Stream stream, Configuration.Writable.WritableConfigurationOptions<T> options)
            where T :  class { }
        public override System.Threading.Tasks.Task SaveAsync<T>(T config, Configuration.Writable.OptionOperations<T> operations, Configuration.Writable.WritableConfigurationOptions<T> options, System.Threading.CancellationToken cancellationToken = default)
            where T :  class { }
    }
    public abstract class WritableConfigProviderBase : Configuration.Writable.IWritableConfigProvider
    {
        protected WritableConfigProviderBase() { }
        public abstract string FileExtension { get; }
        public virtual Configuration.Writable.FileProvider.IFileProvider FileProvider { get; set; }
        public abstract T LoadConfiguration<T>(Configuration.Writable.WritableConfigurationOptions<T> options)
            where T :  class;
        public abstract T LoadConfiguration<T>(System.IO.Stream stream, Configuration.Writable.WritableConfigurationOptions<T> options)
            where T :  class;
        public abstract System.Threading.Tasks.Task SaveAsync<T>(T config, Configuration.Writable.OptionOperations<T> operations, Configuration.Writable.WritableConfigurationOptions<T> options, System.Threading.CancellationToken cancellationToken = default)
            where T :  class;
        protected static object CreateNestedSection(string sectionName, object value) { }
        protected static string[] GetSplitedSections(string sectionName) { }
    }
    public class WritableConfigurationOptionsBuilder<T> : System.IEquatable<Configuration.Writable.WritableConfigurationOptionsBuilder<T>>
        where T :  class
    {
        public WritableConfigurationOptionsBuilder() { }
        public string ConfigFilePath { get; }
        public string DefaultSectionName { get; }
        public string? FilePath { get; set; }
        public Configuration.Writable.FileProvider.IFileProvider? FileProvider { get; set; }
        public System.IO.Stream? FileReadStream { get; set; }
        public string InstanceName { get; set; }
        public Microsoft.Extensions.Logging.ILogger? Logger { get; set; }
        public Configuration.Writable.IWritableConfigProvider Provider { get; set; }
        public bool RegisterInstanceToContainer { get; set; }
        public string SectionName { get; set; }
        public bool UseDataAnnotationsValidation { get; set; }
        public Configuration.Writable.WritableConfigurationOptions<T> BuildOptions() { }
        public string UseCurrentDirectory() { }
        public string UseExecutableDirectory() { }
        public string UseStandardSaveLocation(string applicationId) { }
        public void WithValidator(Microsoft.Extensions.Options.IValidateOptions<T> validator) { }
        public void WithValidator<TValidator>()
            where TValidator : Microsoft.Extensions.Options.IValidateOptions<T>, new () { }
        public void WithValidatorFunction(System.Func<T, Microsoft.Extensions.Options.ValidateOptionsResult> validator) { }
    }
    public class WritableConfigurationOptions<T> : System.IEquatable<Configuration.Writable.WritableConfigurationOptions<T>>
        where T :  class
    {
        public WritableConfigurationOptions() { }
        public required string ConfigFilePath { get; init; }
        public required string InstanceName { get; init; }
        public Microsoft.Extensions.Logging.ILogger? Logger { get; init; }
        public required Configuration.Writable.IWritableConfigProvider Provider { get; init; }
        public required string SectionName { get; init; }
        public System.Func<T, Microsoft.Extensions.Options.ValidateOptionsResult>? Validator { get; init; }
    }
    public static class WritableOptionsCoreExtensions
    {
        public static Microsoft.Extensions.DependencyInjection.IServiceCollection AddWritableOptionsCore<T>(this Microsoft.Extensions.DependencyInjection.IServiceCollection services)
            where T :  class { }
    }
    public class WritableOptionsSimpleInstance<T>
        where T :  class
    {
        public WritableOptionsSimpleInstance() { }
        public Configuration.Writable.IWritableOptions<T> GetOptions() { }
        public void Initialize() { }
        public void Initialize(System.Action<Configuration.Writable.WritableConfigurationOptionsBuilder<T>> configurationOptions) { }
    }
}
namespace Configuration.Writable.Testing
{
    public static class WritableOptionsStub
    {
        public static Configuration.Writable.Testing.WritableOptionsStub<T> Create<T>(System.Collections.Generic.Dictionary<string, T> namedValues)
            where T :  class { }
        public static Configuration.Writable.Testing.WritableOptionsStub<T> Create<T>(T value)
            where T :  class { }
    }
    public class WritableOptionsStub<T> : Configuration.Writable.IReadOnlyOptions<T>, Configuration.Writable.IWritableOptions<T>, Microsoft.Extensions.Options.IOptionsMonitor<T>
        where T :  class
    {
        public WritableOptionsStub(System.Collections.Generic.Dictionary<string, T> namedValues) { }
        public WritableOptionsStub(T value) { }
        public T CurrentValue { get; }
        public T Get(string? name) { }
        public Configuration.Writable.WritableConfigurationOptions<T> GetConfigurationOptions() { }
        public Configuration.Writable.WritableConfigurationOptions<T> GetConfigurationOptions(string name) { }
        public System.IDisposable? OnChange(System.Action<T, string?> listener) { }
        public System.Threading.Tasks.Task SaveAsync(System.Action<T> configUpdater, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task SaveAsync(System.Action<T, Configuration.Writable.IOptionOperator<T>> configUpdaterWithOperator, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task SaveAsync(T newConfig, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task SaveWithNameAsync(string name, System.Action<T> configUpdater, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task SaveWithNameAsync(string name, System.Action<T, Configuration.Writable.IOptionOperator<T>> configUpdaterWithOperator, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task SaveWithNameAsync(string name, T newConfig, System.Threading.CancellationToken cancellationToken = default) { }
    }
}