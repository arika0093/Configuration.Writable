using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace Configuration.Writable.FormatProvider;

/// <summary>
/// AOT-compatible writable configuration implementation for JSON files using JsonSerializerContext.
/// This provider uses source-generated JSON serialization to support Native AOT scenarios.
/// </summary>
/// <remarks>
/// Initializes a new instance of the <see cref="JsonAotFormatProvider"/> class
/// with the specified type info resolver.
/// </remarks>
/// <param name="typeInfoResolver">
/// The JSON type info resolver to use for serialization and deserialization.
/// This is typically a JsonSerializerContext generated by the source generator.
/// </param>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="typeInfoResolver"/> is null.</exception>
public class JsonAotFormatProvider(IJsonTypeInfoResolver typeInfoResolver) : FormatProviderBase
{
    /// <summary>
    /// Gets or sets the options to use when serializing and deserializing JSON data.
    /// If not set, uses the options from the type info resolver (when it is a JsonSerializerContext).
    /// </summary>
    public JsonSerializerOptions? JsonSerializerOptions { get; init; }

    /// <summary>
    /// Gets or sets the text encoding used for processing text data.
    /// </summary>
    public Encoding Encoding { get; init; } = Encoding.UTF8;

    /// <inheritdoc />
    public override string FileExtension => "json";

    /// <summary>
    /// Gets the effective JsonSerializerOptions, either from the property or derived from the type info resolver.
    /// </summary>
    private JsonSerializerOptions GetEffectiveOptions()
    {
        if (JsonSerializerOptions != null)
        {
            return JsonSerializerOptions;
        }

        // If the resolver is a JsonSerializerContext, use its options
        if (typeInfoResolver is JsonSerializerContext context)
        {
            return context.Options;
        }

        // Fallback: create options with the resolver
        return new JsonSerializerOptions
        {
            TypeInfoResolver = typeInfoResolver,
            WriteIndented = false,
        };
    }

    /// <inheritdoc />
    public override object LoadConfiguration(
        Type type,
        Stream stream,
        List<string> sectionNameParts
    )
    {
        var options = GetEffectiveOptions();
        var jsonTypeInfo = options.GetTypeInfo(type);

        var jsonDocument = JsonDocument.Parse(stream);
        var root = jsonDocument.RootElement;

        // Navigate to the section if specified
        if (sectionNameParts.Count > 0)
        {
            var current = root;

            foreach (var section in sectionNameParts)
            {
                if (current.TryGetProperty(section, out var element))
                {
                    current = element;
                }
                else
                {
                    // Section not found, return default instance
                    return Activator.CreateInstance(type)!;
                }
            }

            return JsonSerializer.Deserialize(current.GetRawText(), jsonTypeInfo)
                ?? Activator.CreateInstance(type)!;
        }

        return JsonSerializer.Deserialize(root.GetRawText(), jsonTypeInfo)
            ?? Activator.CreateInstance(type)!;
    }

    /// <inheritdoc />
    public override async Task SaveAsync<T>(
        T config,
        WritableOptionsConfiguration<T> options,
        CancellationToken cancellationToken = default
    )
    {
        var contents = GetSaveContents(config, options);
        await options
            .FileProvider.SaveToFileAsync(
                options.ConfigFilePath,
                contents,
                options.Logger,
                cancellationToken
            )
            .ConfigureAwait(false);
    }

    /// <summary>
    /// Gets the save contents for the configuration.
    /// </summary>
    private ReadOnlyMemory<byte> GetSaveContents<T>(
        T config,
        WritableOptionsConfiguration<T> options
    )
        where T : class, new()
    {
        options.Logger?.Log(
            LogLevel.Trace,
            "Serializing configuration of type {ConfigType} to JSON using AOT provider",
            typeof(T).Name
        );

        var sections = options.SectionNameParts;
        var serializerOptions = GetEffectiveOptions();

        if (sections.Count == 0)
        {
            // No section name, serialize directly (full file overwrite)
            options.Logger?.Log(
                LogLevel.Trace,
                "Serializing configuration directly without section nesting"
            );

            using var stream = new MemoryStream();
            using var writer = new Utf8JsonWriter(
                stream,
                new JsonWriterOptions
                {
                    Indented = serializerOptions.WriteIndented,
                    Encoder = serializerOptions.Encoder,
                }
            );

            var typeInfo = serializerOptions.GetTypeInfo(typeof(T));
            JsonSerializer.Serialize(writer, config, typeInfo);
            writer.Flush();
            var bytes = stream.ToArray();

            options.Logger?.Log(
                LogLevel.Trace,
                "JSON serialization completed successfully, size: {Size} bytes",
                bytes.Length
            );

            return bytes;
        }
        else
        {
            // Section specified - use partial write (merge with existing file)
            options.Logger?.Log(
                LogLevel.Trace,
                "Using partial write for section: {SectionName}",
                string.Join(":", sections)
            );

            return GetPartialSaveContents(config, options);
        }
    }

    /// <summary>
    /// Gets the save contents for partial write (when SectionName is specified).
    /// Reads existing file and merges the new configuration into the specified section.
    /// </summary>
    private ReadOnlyMemory<byte> GetPartialSaveContents<T>(
        T config,
        WritableOptionsConfiguration<T> options
    )
        where T : class, new()
    {
        var sections = options.SectionNameParts;
        var serializerOptions = GetEffectiveOptions();
        JsonDocument? existingDocument = null;

        // Try to read existing file
        if (options.FileProvider.FileExists(options.ConfigFilePath))
        {
            try
            {
                using var fileStream = options.FileProvider.GetFileStream(options.ConfigFilePath);
                if (fileStream != null && fileStream.Length > 0)
                {
                    existingDocument = JsonDocument.Parse(fileStream);
                    options.Logger?.Log(
                        LogLevel.Trace,
                        "Loaded existing JSON file for partial update"
                    );
                }
            }
            catch (JsonException ex)
            {
                options.Logger?.Log(
                    LogLevel.Warning,
                    ex,
                    "Failed to parse existing JSON file, will create new file structure"
                );
            }
        }

        using var stream = new MemoryStream();
        using var writer = new Utf8JsonWriter(
            stream,
            new JsonWriterOptions
            {
                Indented = serializerOptions.WriteIndented,
                Encoder = serializerOptions.Encoder,
            }
        );

        var typeInfo = serializerOptions.GetTypeInfo(typeof(T));

        if (existingDocument != null)
        {
            using (existingDocument)
            {
                // Merge with existing document
                WritePartialUpdate(
                    writer,
                    existingDocument.RootElement,
                    sections,
                    0,
                    config,
                    typeInfo
                );
            }
        }
        else
        {
            // No existing file, create new nested structure
            options.Logger?.Log(
                LogLevel.Trace,
                "Creating new nested section structure for section: {SectionName}",
                string.Join(":", sections)
            );

            writer.WriteStartObject();
            WriteNestedSections(writer, sections, 0, config, typeInfo);
            writer.WriteEndObject();
        }

        writer.Flush();
        var bytes = stream.ToArray();

        options.Logger?.Log(
            LogLevel.Trace,
            "Partial JSON serialization completed successfully, size: {Size} bytes",
            bytes.Length
        );

        return bytes;
    }

    /// <summary>
    /// Writes a partial update by merging existing JSON with new configuration at the specified section path.
    /// </summary>
    private static void WritePartialUpdate<T>(
        Utf8JsonWriter writer,
        JsonElement existingElement,
        List<string> sections,
        int currentIndex,
        T config,
        JsonTypeInfo typeInfo
    )
        where T : class, new()
    {
        if (currentIndex >= sections.Count)
        {
            // Reached the target section depth, write the config
            JsonSerializer.Serialize(writer, config, typeInfo);
            return;
        }

        var targetSection = sections[currentIndex];

        if (existingElement.ValueKind != JsonValueKind.Object)
        {
            // Existing element is not an object, replace with new structure
            writer.WriteStartObject();
            WriteNestedSections(writer, sections, currentIndex, config, typeInfo);
            writer.WriteEndObject();
            return;
        }

        // Write object and merge properties
        writer.WriteStartObject();

        foreach (var property in existingElement.EnumerateObject())
        {
            if (property.Name == targetSection)
            {
                // This is the target section, recurse or replace
                writer.WritePropertyName(property.Name);

                if (currentIndex == sections.Count - 1)
                {
                    // This is the final section, replace with new config
                    JsonSerializer.Serialize(writer, config, typeInfo);
                }
                else
                {
                    // More sections to go, recurse
                    WritePartialUpdate(
                        writer,
                        property.Value,
                        sections,
                        currentIndex + 1,
                        config,
                        typeInfo
                    );
                }
            }
            else
            {
                // Copy other properties as-is
                writer.WritePropertyName(property.Name);
                property.Value.WriteTo(writer);
            }
        }

        // If target section doesn't exist in existing document, add it
        if (!existingElement.TryGetProperty(targetSection, out _))
        {
            WriteNestedSections(writer, sections, currentIndex, config, typeInfo);
        }

        writer.WriteEndObject();
    }

    /// <summary>
    /// Recursively writes nested section structure using Utf8JsonWriter.
    /// </summary>
    private static void WriteNestedSections<T>(
        Utf8JsonWriter writer,
        List<string> sections,
        int currentIndex,
        T config,
        JsonTypeInfo typeInfo
    )
        where T : class, new()
    {
        if (currentIndex >= sections.Count)
        {
            return;
        }

        var sectionName = sections[currentIndex];
        writer.WritePropertyName(sectionName);

        if (currentIndex == sections.Count - 1)
        {
            // Last section, write the actual configuration
            JsonSerializer.Serialize(writer, config, typeInfo);
        }
        else
        {
            // More sections to go, write nested object
            writer.WriteStartObject();
            WriteNestedSections(writer, sections, currentIndex + 1, config, typeInfo);
            writer.WriteEndObject();
        }
    }
}
