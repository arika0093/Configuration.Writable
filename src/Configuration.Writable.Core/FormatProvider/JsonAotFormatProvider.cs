using System;
using System.Collections.Generic;
using System.IO.Pipelines;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace Configuration.Writable.FormatProvider;

/// <summary>
/// AOT-compatible writable configuration implementation for JSON files using JsonSerializerContext.
/// This provider uses source-generated JSON serialization to support Native AOT scenarios.
/// </summary>
/// <remarks>
/// <para>
/// Initializes a new instance of the <see cref="JsonAotFormatProvider"/> class
/// with the specified type info resolver.
/// </para>
/// </remarks>
/// <param name="typeInfoResolver">
/// The JSON type info resolver to use for serialization and deserialization.
/// This is typically a JsonSerializerContext generated by the source generator.
/// </param>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="typeInfoResolver"/> is null.</exception>
public class JsonAotFormatProvider(IJsonTypeInfoResolver typeInfoResolver) : FormatProviderBase
{
    private readonly IJsonTypeInfoResolver _typeInfoResolver =
        typeInfoResolver ?? throw new ArgumentNullException(nameof(typeInfoResolver));

    /// <summary>
    /// Gets or sets the options to use when serializing and deserializing JSON data.
    /// If not set, uses the options from the type info resolver (when it is a JsonSerializerContext).
    /// </summary>
    public JsonSerializerOptions? JsonSerializerOptions { get; init; }

    /// <summary>
    /// Gets or sets the text encoding used for processing text data.
    /// </summary>
    public Encoding Encoding { get; init; } = Encoding.UTF8;

    /// <inheritdoc />
    public override string FileExtension => "json";

    /// <summary>
    /// Gets the effective JsonSerializerOptions, either from the property or derived from the type info resolver.
    /// </summary>
    private JsonSerializerOptions GetEffectiveOptions()
    {
        if (JsonSerializerOptions != null)
        {
            return JsonSerializerOptions;
        }

        // If the resolver is a JsonSerializerContext, use its options
        if (_typeInfoResolver is JsonSerializerContext context)
        {
            return context.Options;
        }

        // Fallback: create options with the resolver
        return new JsonSerializerOptions
        {
            TypeInfoResolver = _typeInfoResolver,
            WriteIndented = false,
        };
    }

    /// <inheritdoc />
    public override async ValueTask<object> LoadConfigurationAsync(
        Type type,
        PipeReader reader,
        List<string> sectionNameParts,
        CancellationToken cancellationToken = default
    )
    {
        var options = GetEffectiveOptions();
        var jsonTypeInfo = options.GetTypeInfo(type);

        // Use JsonDocument.ParseAsync for efficient pipeline-based parsing
        using var stream = reader.AsStream(leaveOpen: false);
        var jsonDocument = await JsonDocument
            .ParseAsync(stream, default, cancellationToken)
            .ConfigureAwait(false);
        var root = jsonDocument.RootElement;

        // Navigate to the section if specified
        if (sectionNameParts.Count > 0)
        {
            if (JsonWriterHelper.TryNavigateToSection(root, sectionNameParts, out var current))
            {
                return JsonSerializer.Deserialize(current.GetRawText(), jsonTypeInfo)
                    ?? Activator.CreateInstance(type)!;
            }
            else
            {
                // Section not found, return default instance
                return Activator.CreateInstance(type)!;
            }
        }

        return JsonSerializer.Deserialize(root.GetRawText(), jsonTypeInfo)
            ?? Activator.CreateInstance(type)!;
    }

    /// <inheritdoc />
    public override async Task SaveAsync<T>(
        T config,
        WritableOptionsConfiguration<T> options,
        CancellationToken cancellationToken = default
    )
    {
        var contents = GetSaveContents(config, options);
        await options
            .FileProvider.SaveToFileAsync(
                options.ConfigFilePath,
                contents,
                options.Logger,
                cancellationToken
            )
            .ConfigureAwait(false);
    }

    /// <summary>
    /// Gets the save contents for the configuration.
    /// </summary>
    private ReadOnlyMemory<byte> GetSaveContents<T>(
        T config,
        WritableOptionsConfiguration<T> options
    )
        where T : class, new()
    {
        options.Logger?.Log(
            LogLevel.Trace,
            "Serializing configuration of type {ConfigType} to JSON using AOT provider",
            typeof(T).Name
        );

        var sections = options.SectionNameParts;
        var serializerOptions = GetEffectiveOptions();
        var typeInfo = serializerOptions.GetTypeInfo(typeof(T));
        var serializeAction = CreateSerializeAction<T>(typeInfo);
        var writerOptions = new JsonWriterOptions
        {
            Indented = serializerOptions.WriteIndented,
            Encoder = serializerOptions.Encoder,
        };

        if (sections.Count == 0)
        {
            return JsonWriterHelper.GetFullSaveContents(
                config,
                writerOptions,
                serializeAction,
                options.Logger
            );
        }
        else
        {
            options.Logger?.Log(
                LogLevel.Trace,
                "Using partial write for section: {SectionName}",
                string.Join(":", sections)
            );

            return JsonWriterHelper.GetPartialSaveContents(
                config,
                sections,
                writerOptions,
                serializeAction,
                options.FileProvider,
                options.ConfigFilePath,
                options.Logger
            );
        }
    }

    /// <summary>
    /// Creates a serialize action for the given JsonTypeInfo.
    /// </summary>
    private static JsonSerializeAction<T> CreateSerializeAction<T>(JsonTypeInfo typeInfo)
        where T : class, new()
    {
        return (writer, value) => JsonSerializer.Serialize(writer, value, typeInfo);
    }
}
